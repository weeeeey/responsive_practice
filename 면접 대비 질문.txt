⭐️ 브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?
⭐️ GET과 POST의 차이는 무엇인가요?
⭐️ 객체 지향 프로그래밍이란 무엇인가요?
⭐️ 프로세스와 스레드에 대해 설명해주세요.
⭐️ Promise와 Callback 차이를 설명해주세요.
⭐️ async, await 사용 방법을 설명해주세요.
⭐️ var, let, const 차이를 설명해주세요.
⭐️ 이벤트 버블링과 캡처링에 대해 설명해주세요.
⭐️ 클로져(Closure)에 대해 설명해주세요.
⭐️ 실행 컨텍스트에 대해 설명해주세요.
⭐️ 호이스팅(hoisting)에 대해 설명해주세요.
⭐️ 프로토타입에 대해 설명해주세요.
⭐️ 불변성을 유지하려면 어떻게 해야하나요?
⭐️ Virtual DOM 작동 원리에 대해 설명해주세요.
⭐️ Virtual DOM 이 무엇인지 설명해주세요.
⭐️ React를 사용하는 이유에 대해 말씀해주세요.
⭐️ 클래스형 컴포넌트와 함수형 컴포넌트의 차이에 대해 설명해주세요.
⭐️ 생명 주기 메서드에 대해 설명해주세요.
⭐️ 리액트에서 JSX 문법이 어떻게 사용되나요?
⭐️ useMemo와 useCallback에 대해 설명해주세요.
⭐️ 리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나요?
⭐️ Context API에 대해 설명해주세요.
⭐️ Redux를 사용하는 이유가 무엇인가요?
⭐️ Redux의 장단점에 대해 설명해주세요.
⭐️ Context API와 Redux를 비교해주세요.
⭐️ 브라우저 렌더링 과정을 설명해주세요.
⭐️ 브라우저는 어떻게 동작 하나요?
⭐️ Webpack, Babel, Polyfill에 대해 설명해주세요.
⭐️ CSR과 SSR의 차이는 무엇인가요?
⭐️ CORS는 무엇인지, 이를 처리를 해본 경험을 말씀해주세요.
⭐️ 웹 표준을 지키며 개발하시나요?
⭐️ 이벤트 루프와 태스크 큐에 대해 설명해주세요.
⭐️ 타입스크립트를 사용하는 이유는 무엇인가요?
⭐️ 쿠키, 세션, 웹스토리지의 차이에 대해 설명해주세요.
⭐️ 웹사이트 성능 최적화에는 어떤 방법이 있나요?
⭐️ Cascading에 관해서 설명해주세요.
⭐️ CSS 애니메이션과 JS 애니메이션의 차이에 대해 설명해주세요.
⭐️ 자기소개를 해주세요.
⭐️ 최근 경험했던 기억에 남는 에러에 대해 말씀해주세요.
⭐️ 요즘 공부하고 있는 것을 말씀해주세요.
⭐️ 좋은 코드란 어떤 것이라고 생각하시나요?
⭐️ 협업할 때 어려운 점이 있었나요?
⭐️ 프로젝트에서 어떤 업무를 주로 담당했나요?
⭐️ 왜 개발자가 되기로 결심하셨나요?
⭐️ 새로운 기술을 습득하기 위해 어떤 방식으로 접근하고 계신가요?
⭐️ 저희 회사에 궁금한 점이 있으신가요?


⭐️ 브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?
브라우저는 주소창에 입력된 주소를 해석하고 해당 웹 사이트의 서버에 HTTP 요청을 보냅니다. 서버는 요청을 받아 해당 웹 페이지의 데이터와 리소스를 가져와 브라우저에 전송합니다. 브라우저는 받은 데이터를 렌더링하여 사용자에게 웹 페이지를 표시합니다.

⭐️ GET과 POST의 차이는 무엇인가요?
GET은 데이터를 URL에 첨부하여 요청하는 방식으로 주로 정보를 조회할 때 사용합니다. POST는 요청 데이터를 HTTP 요청 본문에 담아 서버로 전송하며, 주로 데이터를 생성 또는 수정할 때 사용합니다. GET은 주로 캐시될 수 있고, POST는 더 많은 데이터를 보낼 수 있으며 보안에 더 적합합니다.

⭐️ 객체 지향 프로그래밍이란 무엇인가요?
객체 지향 프로그래밍은 프로그램을 객체들의 모임으로 구성하는 프로그래밍 패러다임입니다. 이 객체들은 데이터와 메서드(함수)를 함께 묶어 캡슐화하고, 상속과 다형성을 지원하여 코드의 재사용성과 유지보수성을 향상시킵니다.

⭐️ 프로세스와 스레드에 대해 설명해주세요.
프로세스는 실행 중인 프로그램을 나타내며, 독립적인 메모리 공간을 가지고 동작합니다. 스레드는 프로세스 내에서 실행되는 작은 실행 단위로, 프로세스의 메모리 공간을 공유합니다. 멀티스레딩은 여러 스레드가 동시에 실행되는 것을 의미하며, 멀티프로세싱은 여러 프로세스가 독립적으로 실행되는 것을 의미합니다.

⭐️ Promise와 Callback 차이를 설명해주세요.
Callback은 비동기 작업을 처리하기 위한 콜백 함수를 사용하는 방식으로 콜백 헬(callback hell) 문제가 발생할 수 있습니다. Promise는 비동기 작업의 결과를 나타내는 객체로, then() 및 catch()를 사용하여 더 간결하게 비동기 코드를 작성할 수 있습니다.

⭐️ async, await 사용 방법을 설명해주세요.
async 함수 내에서 await 키워드를 사용하여 비동기 작업을 동기적으로 처리할 수 있습니다. await는 Promise가 해결될 때까지 함수의 실행을 일시 중단하고 결과를 반환합니다. 이를 통해 비동기 코드를 더 읽기 쉽게 작성할 수 있습니다.

⭐️ var, let, const 차이를 설명해주세요.
var는 함수 스코프를 가지고 있으며, 중복 선언이 가능하고 호이스팅 현상이 있습니다. let과 const는 블록 스코프를 가지며 중복 선언이 불가능하고 호이스팅이 발생하지 않습니다. let은 재할당이 가능하고, const는 상수로 선언된 변수로 재할당이 불가능합니다.

⭐️ 이벤트 버블링과 캡처링에 대해 설명해주세요.
이벤트 버블링은 HTML 요소에서 이벤트가 발생한 후 부모 요소로 이벤트가 전파되는 현상을 의미합니다. 캡처링은 이와 반대로 이벤트가 부모 요소부터 자식 요소로 전파되는 현상입니다. 브라우저에서는 이벤트 버블링과 캡처링을 활용하여 이벤트 핸들러를 선택적으로 실행할 수 있습니다.

⭐️ 클로져(Closure)에 대해 설명해주세요.
클로져는 함수가 해당 함수의 렉시컬 스코프 외부에서 변수를 참조할 때 생성됩니다. 클로져는 해당 외부 변수를 기억하고 사용할 수 있는 함수를 의미하며, 함수와 그 함수가 참조하는 변수들로 구성됩니다. 이를 통해 변수의 상태를 보존하고 비동기 작업 및 콜백에서 유용하게 사용할 수 있습니다.

⭐️ 실행 컨텍스트에 대해 설명해주세요.
실행 컨텍스트는 JavaScript 코드가 실행되는 환경을 나타내며, 변수, 함수 선언 및 스코프 정보를 관리합니다. 실행 컨텍스트는 스택(Stack)에 쌓이며, 현재 실행 중인 함수의 정보와 변수들을 저장합니다. 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성되고 스택에 푸시됩니다.

⭐️ 호이스팅(hoisting)에 대해 설명해주세요.
호이스팅은 JavaScript에서 변수 및 함수 선언이 스코프 내에서 최상단으로 끌어올려지는 현상을 의미합니다. 이는 변수와 함수를 선언하기 전에 참조할 수 있다는 것을 의미하지만, 할당은 실제 위치에서 이루어집니다. 이해하기 쉽게 코드를 작성하기 위해 변수와 함수는 사용하기 전에 선언하는 것이 좋습니다.

⭐️ 프로토타입에 대해 설명해주세요.
프로토타입은 객체 지향 프로그래밍에서 객체 간의 상속을 구현하는 메커니즘입니다. 모든 객체는 프로토타입 객체를 가지며, 프로토타입 체인을 통해 상위 객체의 속성과 메서드를 상속받을 수 있습니다. JavaScript에서 객체는 프로토타입을 통해 다른 객체로부터 속성 및 메서드를 상속받습니다.

⭐️ 불변성을 유지하려면 어떻게 해야하나요?
불변성을 유지하려면 기존 데이터를 수정하지 않고 새로운 데이터를 생성해야 합니다. 예를 들어, 배열을 수정하는 대신 배열의 복사본을 만들고 수정합니다. 이를 통해 예상치 못한 부작용을 방지하고 데이터의 안정성을 유지할 수 있습니다.

⭐️ Virtual DOM 작동 원리에 대해 설명해주세요.
Virtual DOM은 리액트에서 사용되는 개념으로, 실제 DOM의 가벼운 복제본을 나타냅니다. 상태 변경 시, 리액트는 Virtual DOM을 업데이트하고 이전 Virtual DOM과 비교하여 변경된 부분만을 실제 DOM에 적용합니다. 이를 통해 DOM 조작을 최소화하고 성능을 향상시킵니다.

⭐️ Virtual DOM이 무엇인지 설명해주세요.
Virtual DOM은 실제 DOM의 가상 복제본으로, 메모리에 존재하는 가벼운 구조입니다. 리액트와 같은 라이브러리에서 사용되며, 상태 변경 시에 Virtual DOM을 업데이트하고 이전 Virtual DOM과 비교하여 DOM 조작을 최소화합니다.

⭐️ React를 사용하는 이유에 대해 말씀해주세요.
React는 UI를 빠르고 효율적으로 개발하기 위한 라이브러리로, 다음과 같은 이유로 사용됩니다:
가상 DOM을 통한 빠른 렌더링.
컴포넌트 기반 아키텍처로 코드 재사용과 유지보수 용이성.
단방향 데이터 흐름으로 예측 가능한 상태 관리.
생태계가 풍부하고 커뮤니티 활성화.

⭐️ 클래스형 컴포넌트와 함수형 컴포넌트의 차이에 대해 설명해주세요.
클래스형 컴포넌트는 ES6 클래스를 기반으로 구현되며, state와 생명 주기 메서드를 사용하여 컴포넌트를 관리합니다. 함수형 컴포넌트는 함수로 구현되며, React Hook을 사용하여 상태와 생명 주기 기능을 함수 안에서 사용할 수 있습니다. 함수형 컴포넌트는 코드가 더 간결하고 이해하기 쉽고 테스트하기 쉽다는 장점이 있습니다.

⭐️ 생명 주기 메서드에 대해 설명해주세요.
생명 주기 메서드는 React 컴포넌트의 라이프사이클 동안 호출되는 특별한 메서드입니다. 주요 생명 주기 메서드에는 componentDidMount, componentDidUpdate, componentWillUnmount 등이 있으며, 컴포넌트의 마운트, 업데이트 및 언마운트 단계에서 특정 작업을 수행할 수 있도록 합니다.

⭐️ 리액트에서 JSX 문법이 어떻게 사용되나요?
JSX는 JavaScript XML의 약어로, React에서 UI를 정의하는 데 사용됩니다. JSX는 HTML과 유사한 문법으로 컴포넌트의 구조와 모양을 선언하며, Babel과 같은 트랜스파일러를 사용하여 일반 JavaScript 코드로 변환됩니다.

⭐️ useMemo와 useCallback에 대해 설명해주세요.
useMemo는 계산 비용이 높은 값을 캐시하여 성능을 향상시키는 Hook입니다. useCallback은 함수를 캐시하여 불필요한 함수 생성을 방지하고 렌더링 성능을 최적화합니다. 둘 다 의존성 배열을 사용하여 어떤 상황에서 캐시를 업데이트할지 지정할 수 있습니다.

⭐️ 리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나요?
렌더링 성능을 향상시키려면 다음과 같은 방법을 고려할 수 있습니다:
불필요한 렌더링 최소화 (PureComponent, memo 등 사용).
컴포넌트 분할 (작은 컴포넌트로 분리).
React DevTools를 사용한 성능 프로파일링.
불필요한 렌더링을 방지하는 useMemo와 useCallback 사용.
데이터 가져오기 및 처리 시 비동기 작업 최적화.

⭐️ Context API에 대해 설명해주세요.
Context API는 React의 상태를 전역으로 관리하기 위한 도구로, 컴포넌트 계층 구조를 깊게 네스팅하지 않고도 데이터를 공유할 수 있게 해줍니다. createContext를 사용하여 context를 생성하고 Provider와 Consumer를 사용하여 데이터를 제공 및 소비합니다.

⭐️ Redux를 사용하는 이유가 무엇인가요?
Redux는 React 애플리케이션의 상태 관리를 단순화하고 예측 가능하게 만드는 도구입니다. Redux를 사용하는 이유는 다음과 같습니다:
중앙화된 상태 관리로 데이터 흐름을 관리.
예측 가능한 애플리케이션 상태.
디버깅 및 테스트 용이성.

⭐️ Redux의 장단점에 대해 설명해주세요.
Redux의 장점:

중앙화된 상태 관리로 상태 관리 복잡성 감소.

예측 가능한 상태 변화.

미들웨어를 통한 비동기 작업 관리 용이.

Redux의 단점:

러닝 커브가 존재하며 초기 설정이 번거로울 수 있음.

작은 규모의 애플리케이션에서는 비용이 높을 수 있음.

과도한 사용은 불필요한 복잡성을 초래할 수 있음.


⭐️ Context API와 Redux를 비교해주세요.
Context API:

리액트 공식 지원.

단순한 애플리케이션 상태 관리에 적합.

컴포넌트 계층 내에서 데이터 전달 용이.

Redux에 비해 더 가벼운 솔루션.

Redux:

복잡한 상태 관리에 적합.

중앙화된 상태 저장소.

미들웨어를 통한 비동기 작업 관리 가능.

커뮤니티 및 미들웨어 풍부.


⭐️ 브라우저 렌더링 과정을 설명해주세요.
브라우저 렌더링 과정은 다음과 같습니다:
HTML 파싱: HTML 문서를 파싱하여 DOM 트리 생성.
CSS 파싱: CSS 스타일 정보를 파싱하여 스타일 규칙 생성.
렌더 트리 구성: DOM 트리와 스타일 규칙을 결합하여 렌더 트리 생성.
레이아웃: 렌더 트리의 각 노드의 위치와 크기 계산.
페인팅: 렌더링 엔진이 렌더 트리를 사용하여 화면에 그림을 그림.

⭐️ 브라우저는 어떻게 동작 하나요?
브라우저는 다음과 같은 주요 구성 요소로 동작합니다:
사용자 인터페이스: 주소창, 뒤로/앞으로 버튼 등의 UI를 제공.
브라우저 엔진: HTML 및 CSS 문서 해석, 렌더링 엔진과 상호 작용.
렌더링 엔진: 요청된 내용을 표시하는 역할로, DOM 및 CSS를 처리하고 화면에 그림.
통신: HTTP 요청을 보내고 응답을 받는 네트워크 작업 수행.
자바스크립트 해석기: JavaScript 코드 해석 및 실행.
저장소: 쿠키, 로컬 스토리지 등을 사용하여 데이터 저장.
사용자 인터페이스 백엔드: 콤보 박스 및 창 같은 기본적인 UI 요소 그림.
데이터 스토리지: 쿠키, 로컬 스토리지, 세션 스토리지 등을 사용하여 데이터 저장.

⭐️ Webpack, Babel, Polyfill에 대해 설명해주세요.
Webpack은 JavaScript 애플리케이션을 빌드하는 도구로 모듈 번들러 역할을 합니다. 의존성 관리, 번들링, 코드 최적화 등을 제공합니다.
Babel은 최신 ECMAScript 버전으로 작성된 코드를 이전 버전으로 변환하는 트랜스파일러입니다. 크로스 브라우징 및 호환성을 지원합니다.
Polyfill은 구현되지 않은 웹 표준 기능을 브라우저에서 시뮬레이트하여 지원하는 라이브러리 또는 코드 조각을 말합니다. 구현되지 않은 기능을 지원하기 위해 사용됩니다.

⭐️ CSR과 SSR의 차이는 무엇인가요?
CSR (Client-Side Rendering)은 클라이언트(브라우저)에서 JavaScript를 사용하여 동적으로 웹 페이지를 렌더링하는 방식입니다. 초기 로딩 시에는 빈 페이지가 나타나며 JavaScript 파일을 다운로드하고 실행한 후에 컨텐츠가 표시됩니다. CSR은 초기 로딩 속도가 빠르며, 클라이언트에서 페이지 렌더링을 처리하므로 서버 부담이 감소합니다.

SSR (Server-Side Rendering)은 서버에서 초기 페이지 렌더링을 수행하는 방식입니다. 서버는 요청 시에 HTML을 생성하여 클라이언트에 전송하며, 이로써 초기 로딩 시에 컨텐츠가 즉시 나타납니다. SSR은 검색 엔진 최적화(SEO)와 초기 로딩 성능에 이점을 제공하지만 서버 부담이 높을 수 있습니다.


⭐️ CORS는 무엇인지, 이를 처리를 해본 경험을 말씀해주세요.
CORS (Cross-Origin Resource Sharing)는 웹 애플리케이션의 보안 정책으로, 다른 도메인의 리소스에 접근하는 것을 제한합니다. 웹 애플리케이션은 동일 출처 정책(Same-Origin Policy)에 따라 동일한 출처에서만 리소스를 요청할 수 있습니다.
CORS 처리 경험:

서버 측에서 CORS 헤더를 설정하여 다른 도메인에서의 요청을 허용하거나 거부할 수 있습니다.
클라이언트 측에서는 XMLHttpRequest나 Fetch API를 사용할 때 특정 헤더를 설정하여 CORS 요청을 보낼 수 있습니다.
또한 JSONP와 프록시 서버 등의 기술을 사용하여 CORS를 우회할 수도 있습니다.

⭐️ 웹 표준을 지키며 개발하시나요?
웹 표준을 준수하는 것은 웹 개발의 중요한 측면 중 하나입니다. 웹 표준을 지키면 다음과 같은 이점이 있습니다:
브라우저 호환성 향상.
SEO 개선.
접근성 향상.
코드 유지보수성 개선.
새로운 웹 기술 및 표준을 적용하기 용이.

⭐️ 이벤트 루프와 태스크 큐에 대해 설명해주세요.
이벤트 루프는 JavaScript 실행 환경에서 비동기 코드의 실행을 관리하는 주요 구성 요소입니다. 이벤트 루프는 콜 스택(call stack)과 태스크 큐(task queue)로 구성됩니다.

콜 스택은 현재 실행 중인 함수의 호출 스택을 나타내며, 비동기 작업이 완료되면 해당 콜백 함수가 콜 스택에 푸시됩니다.

태스크 큐는 비동기 작업을 대기시키는 대기열입니다. 이벤트 루프는 콜 스택이 비어있을 때 태스크 큐에서 대기 중인 작업을 콜 스택으로 이동시킵니다.


⭐️ 타입스크립트를 사용하는 이유는 무엇인가요?
타입스크립트는 JavaScript에 정적 타입을 추가하는 언어로, 다음과 같은 이유로 사용됩니다:
코드의 가독성과 유지보수성 향상.
타입 오류를 사전에 방지하여 안정성 향상.
코드 자동 완성과 타입 체크 도구 지원.
대규모 프로젝트에서 협업과 디버깅 용이성 개선.

⭐️ 쿠키, 세션, 웹스토리지의 차이에 대해 설명해주세요.
쿠키 (Cookies):

클라이언트 측에서 저장되는 작은 데이터 조각.

서버와의 통신 시 데이터를 전송하기 위해 사용.

만료 날짜를 설정하여 유지 기간을 제어할 수 있음.

세션 (Session):

서버 측에 사용자 정보를 저장하는 방식.

쿠키를 사용하여 세션 ID를 클라이언트에 저장하고, 서버에서 해당 세션 ID를 사용하여 사용자 데이터를 관리.

세션은 서버가 종료되거나 세션 만료 시점에 삭제됨.

웹 스토리지 (Web Storage):

클라이언트 측에서 키-값 쌍을 저장하는 브라우저 스토리지 영역.

로컬 스토리지 (localStorage): 브라우저를 종료해도 데이터가 유지됨.

세션 스토리지 (sessionStorage): 세션이 종료되면 데이터가 삭제됨.


⭐️ 웹사이트 성능 최적화에는 어떤 방법이 있나요?
웹사이트 성능 최적화를 위한 방법은 다음과 같습니다:
이미지 최적화 및 레이지 로딩 사용.
캐싱을 활용하여 리소스 로딩 시간 단축.
HTTP/2 또는 HTTP/3 사용.
번들링과 코드 스플리팅을 통한 자원 최적화.
비동기 로딩 및 지연 로딩 기법 활용.
렌더링 성능 최적화 (가상 DOM, 최소화된 리렌더링).
반응형 웹 디자인 채택.
서버 사이드 렌더링 (SSR) 적용.

⭐️ Cascading에 관해서 설명해주세요.
Cascading은 CSS의 C 부분으로, 스타일 규칙의 충돌을 해결하는 방식을 나타냅니다. Cascading은 다음과 같은 우선순위로 스타일 규칙을 적용합니다:
중요도 (Importance): !important 키워드가 사용된 스타일이 다른 모든 스타일보다 우선됩니다.
명시도 (Specificity): 선택자의 명시도가 높은 스타일이 우선됩니다.
소스 순서 (Source Order): 같은 중요도와 명시도를 가진 스타일 중에 마지막에 선언된 스타일이 우선됩니다.

⭐️ CSS 애니메이션과 JS 애니메이션의 차이에 대해 설명해주세요.
CSS 애니메이션은 CSS의 @keyframes 규칙을 사용하여 정적으로 정의된 애니메이션입니다. 브라우저의 GPU 가속을 활용하여 부드럽게 애니메이션을 실행하며, 성능이 뛰어납니다. 그러나 제어가 한정적이며 동적인 상황에는 제한적입니다.

JS 애니메이션은 JavaScript 코드로 애니메이션을 동적으로 제어하는 방식입니다. 다양한 상황에 대처할 수 있고, 사용자 입력 또는 서버 데이터와 상호 작용할 수 있습니다. 그러나 성능 문제가 발생할 수 있으며 브라우저의 렌더링 주기와 동기화하기 어려울 수 있습니다.


⭐️ 좋은 코드란 어떤 것이라고 생각하시나요?
좋은 코드는 다음과 같은 특성을 갖추어야 합니다:
가독성: 코드는 다른 사람이 이해하기 쉬워야 합니다.
모듈화: 작은 모듈로 코드를 나누고 재사용성을 높여야 합니다.
효율성: 코드는 최적화되어야 하며 성능을 향상시켜야 합니다.
유지보수성: 코드는 쉽게 수정하고 확장할 수 있어야 합니다.
일관성: 일관된 코딩 스타일과 패턴을 사용하여 혼란을 방지해야 합니다.
테스트 가능성: 코드는 테스트 가능한 형태로 작성되어야 하며 테스트 케이스를 작성할 수 있어야 합니다.

Q: HTTP와 HTTPS의 차이는 무엇인가요?
A: HTTP는 보안 없이 데이터를 전송하는 프로토콜이며, HTTPS는 보안 소켓 계층(SSL/TLS)을 사용하여 데이터를 암호화하는 프로토콜입니다.

Q: 브라우저의 캐싱은 어떻게 동작하나요?
A: 브라우저는 이전에 다운로드한 리소스를 저장하여 다음에 같은 리소스를 요청할 때 서버로부터 받지 않고 로컬에서 로드합니다.

Q: CORS는 무엇이며 어떻게 해결할 수 있나요?
A: Cross-Origin Resource Sharing (CORS)는 다른 출처에서 리소스를 요청하는 보안 정책입니다. 서버에서 헤더를 설정하여 해결할 수 있습니다.

Q: HTTP 요청 메서드(GET, POST 등)에 대해 설명하세요.
A: GET은 리소스를 요청하는데 사용되며, POST는 데이터를 서버에 제출하는데 사용됩니다. 다른 메서드로는 PUT, DELETE 등이 있습니다.

Q: 브라우저에서 DNS 프리페치를 어떻게 사용하나요?
A: <link rel="dns-prefetch">를 사용하여 미리 DNS 조회를 수행할 도메인을 지정할 수 있습니다.

Q: HTTP 상태 코드 404와 500의 의미는 무엇인가요?
A: 404는 "Not Found"를 나타내며, 500은 "Internal Server Error"를 나타냅니다.

Q: 웹 소켓과 일반 HTTP 통신의 차이점은 무엇인가요?
A: 웹 소켓은 양방향 통신을 지원하고 실시간 데이터 전송에 사용되며, 일반 HTTP는 단방향 요청-응답 모델입니다.

Q: HTTP/2와 HTTP/1.1의 주요 차이점은 무엇인가요?
A: HTTP/2는 다중 스트림과 헤더 압축을 지원하여 빠른 성능을 제공하며, HTTP/1.1보다 효율적으로 데이터를 전송합니다.

Q: 브라우저의 렌더링 프로세스는 어떻게 동작하나요?
A: 렌더링 프로세스는 파싱, 렌더 트리 구축, 레이아웃, 페인팅 순서로 진행됩니다.

Q: 브라우저 스토리지의 종류와 차이점을 설명하세요.
A: 브라우저 스토리지에는 로컬 스토리지와 세션 스토리지가 있으며, 로컬 스토리지는 영구적으로 데이터를 저장하고 세션 스토리지는 세션 동안만 데이터를 저장합니다.

Q: 쿠키와 웹 스토리지(Local Storage)의 차이점은 무엇인가요?
A: 쿠키는 서버로 데이터를 자동으로 보냄으로써 상태를 유지하고, 웹 스토리지는 클라이언트 측에서 데이터를 저장하는 데 사용됩니다.

Q: 브라우저의 렌더링 성능을 최적화하기 위해 어떤 방법을 사용할 수 있나요?
A: 이미지 최적화, CSS/JS 압축, 렌더링을 블록하지 않는 비동기 스크립트 로딩 등을 사용하여 성능을 향상시킬 수 있습니다.

Q: 웹페이지의 로딩 속도를 빠르게 만들기 위한 최적화 기술은 어떤 것이 있나요?
A: 이미지 스프라이트, 브라우저 캐싱, CDN 사용, 리소스 번들링, 레이지 로딩 등을 사용하여 로딩 속도를 최적화할 수 있습니다.

Q: 브라우저의 DevTools를 사용하여 성능 문제를 진단하는 방법은 무엇인가요?
A: DevTools의 Performance 탭을 사용하여 로딩 시간, 함수 호출, 렌더링 이벤트 등을 분석하고 성능 문제를 찾을 수 있습니다.

Q: AJAX의 동작 방식을 설명하세요.
A: AJAX는 비동기적으로 서버에 데이터를 요청하고, 응답을 받으면 페이지를 새로 고치지 않고 데이터를 업데이트합니다.

Q: 웹 보안에 관련된 주요 취약점 중 하나를 설명하고 방어 방법을 제시하세요.
A: 크로스사이트 스크립팅(XSS) 공격은 사용자 입력을 신뢰하지 않도록 하고, 입력을 이스케이핑하거나 콘텐츠 보안 정책(CSP)을 사용하여 방어할 수 있습니다.

Q: 로딩 시간이 오래 걸리는 이미지를 최적화하기 위한 방법은 무엇인가요?
A: 이미지 크기를 최적화하고, 웹P 또는 JPEG 2000과 같은 더 효율적인 형식을 사용하며, 이미지 압축 도구를 활용할 수 있습니다.

Q: 웹 앱의 보안을 강화하기 위한 방법은 어떤 것이 있나요?
A: HTTPS 사용, 인증 및 권한 부여 구현, 보안 헤더 설정, 입력 유효성 검사, SQL 인젝션 및 크로스사이트 스크립팅 방어 등을 고려할 수 있습니다.

Q: 웹 페이지의 성능을 측정하기 위한 도구와 메트릭은 어떤 것이 있나요?
A: Google PageSpeed Insights, Lighthouse, Web Vitals 등의 도구와 TTFB, FCP, LCP, CLS, TBT 등의 성능 메트릭을 사용합니다.

Q: 웹 애플리케이션의 로드 밸런싱이 무엇이며 왜 필요한가요?
A: 로드 밸런싱은 서버 부하를 분산시키는 기술로, 트래픽이 많거나 서버 장애를 대비하기 위해 필요합니다. 서버 간의 부하 분산을 수행하고, 가용성을 향상시키며 성능을 향상시킵니다.

DNS:
호스트 서버는 ip 주소로 이루어져 있는데 이것을 사용자가 이해하기 쉬운 도메인 이름으로 변환해준 시스템. (도메인 네임 시스템)